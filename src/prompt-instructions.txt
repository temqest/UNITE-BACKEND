Refactor the entire request-handling logic into a modular, scalable, and role-aware system.
The new system must eliminate hardcoded flows and instead rely on a reusable state machine or rule-based architecture.

Core Requirements
1. Users & Hierarchy

There are three roles:

Admin (System Administrator)

Coordinator

Stakeholder

Hierarchy: Admin → Coordinator → Stakeholder

The system must allow flexible reviewer assignments based on the requester’s role:

If Admin creates a request → Coordinator becomes reviewer

If Coordinator creates a request → Admin becomes reviewer

If Stakeholder creates a request → Coordinator becomes primary reviewer

Admin can still intervene as an override reviewer

This hierarchy must not be hardcoded; it should be configurable.

2. Request Stages & States

Convert the request pipeline into clear states:

Pending Review

Reviewed → Accepted

Reviewed → Rejected

Reviewed → Reschedule Requested

Awaiting Confirmation (from requester)

Approved

Rejected (Final)

Cancelled

Closed

Transitions between states must be rule-based, not manually coded per user.

3. Actions Based on Role + State

Define actions by combining user role + current request state.

Requester Actions

When user is the requester:

Pending: View

After reviewer decision: Confirm, View

If rescheduled: Confirm or Request Reschedule

Approved: View, Edit, Manage Staff, Reschedule, Cancel

Rejected: View

Cancelled: View

Reviewer Actions

When user is the assigned reviewer:

Pending: View, Accept, Reject, Reschedule

If reschedule returned from requester: View, Accept, Reject, Reschedule again

Admin as override reviewer can perform same reviewer actions optionally.

4. Universal Reschedule Loop

Rescheduling must support an infinite loop until both sides finalize.

Behavior:

Reviewer requests reschedule → request goes back to requester

Requester may:

Confirm → finalize & approve

Reschedule again → return to reviewer

This loop must be stable and not break when roles change or when multiple cycles occur.

This must be implemented as reusable transition logic, not custom branches.

5. Flexible, Reusable Flow Engine

Refactor into a system where:

Each state defines which actions are allowed.

Each action defines the next state.

Reviewer assignment is rule-based and configurable.

The system should not depend on rigid “if role A do X, if role B do Y” logic.

The final architecture should allow:

Adding new roles

Changing hierarchy

Adding new states

Customizing reviewer per request type

Reusing same logic across all user scenarios

without rewriting entire flow logic.

6. Goals of the Refactor

Make the entire request flow robust, modular, and easy to extend.

Ensure the flow cannot be broken by small code changes.

Remove duplicated logic.

Keep all transitions clean and predictable.

Maintain full compatibility with existing UI actions, notifications, and backend events.

Deliverables

Rewrite my current system into:

A state machine or rule-based engine

Clear state → allowed actions → next state mapping

Role-based action permissions

Reviewer assignment logic

A stable reschedule loop

Clean APIs for frontend integration