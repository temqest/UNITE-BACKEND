# UNITE Backend v2.0 Architecture Guide
## System Source of Truth for AI-Driven Development

**Version:** 2.0  
**Last Updated:** 2025-01-XX  
**Status:** Production-Ready  
**Compatibility:** Parallel to v1.0 (Backward Compatible)

---

## 1. System Summary & Philosophy

### 1.1 Version 2.0 Goals

**v2.0** is a **permission-first, role-agnostic** refactor of the event request and event management flow. It runs **parallel** to v1.0, ensuring zero breaking changes while providing a cleaner, more maintainable architecture.

**Core Principles:**
1. **Permission-Based Access Control**: All access decisions use `permissionService.checkPermission()` - NO hardcoded role checks
2. **Broadcast Visibility Model**: Requests visible to ANY reviewer with matching jurisdiction (Coverage Area + Organization Type)
3. **Simplified State Machine**: Reduced states focusing on core workflow (pending → approved/rejected/rescheduled)
4. **Reschedule Loop Logic**: Proposer ↔ Responder based on requester vs reviewer identity, NOT role names
5. **Double-Confirmation**: Reviewer decision + Requester confirmation required for finalization

### 1.2 Versioning Strategy

**File Naming Convention:**
- All v2.0 files use `v2.0_` prefix in subfolder names
- Routes use `/api/v2/` prefix
- v1.0 files remain untouched in original locations

**Backward Compatibility:**
- v1.0 routes (`/api/event-requests`) continue to work
- v2.0 routes (`/api/v2/event-requests`) are parallel
- Same database models used (no schema changes)
- Frontend can migrate gradually by switching API endpoints

### 1.3 Architectural Philosophy

**Layered Architecture:**
```
Routes (HTTP) → Controllers (Request/Response) → Services (Business Logic) → Models (Data)
```

**Separation of Concerns:**
- **Routes**: HTTP routing, middleware, validation
- **Controllers**: Request/response formatting, error handling
- **Services**: Business logic, state transitions, permission checks
- **Models**: Data structure, persistence

**State Machine Sovereignty:**
- State transitions are **centralized** in `v2.0_requestStateMachine.js`
- Controllers **MUST NOT** directly update request status
- All transitions **MUST** go through state machine validation

---

## 2. Architectural Directory Map

### 2.1 v2.0 File Structure

```
src/
├── routes/
│   └── v2.0_eventRoutes.js                    # Route definitions (prefix: /api/v2/)
│
├── controller/
│   └── v2.0_eventControllers/
│       ├── eventRequest.controller.js         # HTTP request handlers
│       └── index.js                           # Controller exports
│
├── services/
│   └── v2.0_eventServices/
│       ├── v2.0_requestStateMachine.js        # State machine (WORKFLOW SOVEREIGNTY)
│       ├── v2.0_eventRequest.service.js       # Request lifecycle management
│       ├── v2.0_reviewerResolver.service.js   # Jurisdiction-based reviewer discovery
│       ├── v2.0_event.service.js              # Event creation from approved requests
│       └── index.js                           # Service exports
│
└── validators/
    └── v2.0_eventValidators/
        ├── eventRequest.validators.js          # Joi validation schemas
        └── index.js                            # Validator exports
```

### 2.2 Shared Dependencies (v1.0 & v2.0)

**Models (Shared):**
- `src/models/eventRequests_models/eventRequest.model.js` - Request data model
- `src/models/events_models/event.model.js` - Event data model
- `src/models/users_models/user.model.js` - User data model

**Core Services (Shared):**
- `src/services/users_services/permission.service.js` - Permission checking
- `src/services/users_services/authority.service.js` - Authority calculation
- `src/services/utility_services/notificationEngine.service.js` - Notifications

**Middleware (Shared):**
- `src/middleware/authenticate.js` - Authentication
- `src/middleware/requirePermission.js` - Permission enforcement
- `src/middleware/cacheMiddleware.js` - Response caching

**Constants (Shared):**
- `src/utils/eventRequests/requestConstants.js` - State/action constants

### 2.3 Route Registration

**File:** `src/routes/index.js`

```javascript
// v1.0 routes (existing)
router.use('/api', eventRequestsRoutes);

// v2.0 routes (new)
router.use('/api/v2', v2EventRequestsRoutes);
```

**Route Prefixes:**
- v1.0: `/api/event-requests/*`
- v2.0: `/api/v2/event-requests/*`

---

## 3. Request Lifecycle Flowchart

### 3.1 State Machine States (v2.0 Simplified)

```
pending-review (Initial)
    ├─ accept → approved
    ├─ reject → rejected
    └─ reschedule → review-rescheduled

review-rescheduled (Reschedule Negotiation)
    ├─ accept → approved
    ├─ reject → rejected
    ├─ confirm → approved (requester confirms)
    ├─ decline → rejected (requester declines)
    └─ reschedule → review-rescheduled (LOOP - both parties can counter-reschedule)

approved (Final - Event Created)
    ├─ reschedule → review-rescheduled
    └─ cancel → cancelled

rejected (Final)
    └─ (no transitions)

cancelled (Final)
    └─ (no transitions)
```

### 3.2 Request Creation Flow

```
1. User creates request
   ↓
2. Permission check: request.create OR request.initiate
   ↓
3. Find reviewers via v2.0_reviewerResolver (jurisdiction matching)
   ↓
4. Create request document (status: pending-review)
   ↓
5. Set activeResponder = { relationship: 'reviewer' } (broadcast model)
   ↓
6. Save request
   ↓
7. Send notifications to valid reviewers
```

### 3.3 Action Execution Flow

```
1. User executes action (accept/reject/reschedule/confirm/cancel)
   ↓
2. Permission check via state machine (canTransition)
   ↓
3. State machine validates transition (isValidTransition)
   ↓
4. Get next state (getNextState)
   ↓
5. Update request based on action
   ↓
6. Update activeResponder (for reschedule loop)
   ↓
7. Add status history
   ↓
8. Save request
   ↓
9. If approved → Create event via v2.0_event.service
   ↓
10. Send notifications
```

### 3.4 Reschedule Loop Flow

```
Reviewer Reschedules:
    request.status = review-rescheduled
    activeResponder = { userId: requester.userId, relationship: 'requester' }
    ↓
Requester Responds (confirm/decline/reschedule):
    - confirm → approved
    - decline → rejected
    - reschedule → review-rescheduled (LOOP)
        activeResponder = { relationship: 'reviewer' } (any reviewer can act)

Requester Reschedules:
    request.status = review-rescheduled
    activeResponder = { relationship: 'reviewer' } (any reviewer can act)
    ↓
Reviewer Responds (accept/reject/reschedule):
    - accept → approved
    - reject → rejected
    - reschedule → review-rescheduled (LOOP)
        activeResponder = { userId: requester.userId, relationship: 'requester' }
```

---

## 4. Debugging Matrix

### 4.1 Issue → Target File Mapping

| **Issue** | **Primary File** | **Secondary Files** | **Purpose** |
|-----------|-----------------|---------------------|-------------|
| Request transitions not working | `v2.0_requestStateMachine.js` | `v2.0_eventRequest.service.js` | State machine defines allowed transitions |
| Reviewer visibility incorrect | `v2.0_reviewerResolver.service.js` | `permission.service.js` | Jurisdiction matching logic |
| Permission checks failing | `permission.service.js` | `requirePermission.js` | Permission evaluation |
| Actions not executing | `v2.0_eventRequest.service.js` | `v2.0_requestStateMachine.js` | Action processing logic |
| Events not being created | `v2.0_event.service.js` | `v2.0_eventRequest.service.js` | Event creation from approved requests |
| Reschedule loop broken | `v2.0_requestStateMachine.js` | `v2.0_eventRequest.service.js` | Active responder determination |
| Validation errors | `v2.0_eventValidators/eventRequest.validators.js` | `v2.0_eventRequest.controller.js` | Input validation |
| Response format incorrect | `v2.0_eventRequest.controller.js` | `v2.0_eventRoutes.js` | Response formatting |
| Routes not accessible | `v2.0_eventRoutes.js` | `routes/index.js` | Route registration |

### 4.2 Common Debugging Scenarios

**Scenario 1: "User cannot see request"**
1. Check `v2.0_reviewerResolver.service.js` - jurisdiction matching
2. Check `permission.service.js` - permission evaluation
3. Check `v2.0_eventRequest.service.js` - getRequests() query logic
4. Verify user's coverage areas and organization type

**Scenario 2: "Action not allowed"**
1. Check `v2.0_requestStateMachine.js` - canTransition() method
2. Check `permission.service.js` - permission check for action
3. Check `v2.0_eventRequest.service.js` - executeAction() permission validation
4. Verify user's authority vs requester's authority

**Scenario 3: "Reschedule loop not working"**
1. Check `v2.0_requestStateMachine.js` - determineActiveResponder() method
2. Check `v2.0_eventRequest.service.js` - activeResponder update logic
3. Verify requester vs reviewer identity checks
4. Check request.lastAction.actorId tracking

**Scenario 4: "Event not created after approval"**
1. Check `v2.0_eventRequest.service.js` - executeAction() event creation trigger
2. Check `v2.0_event.service.js` - createEventFromRequest() method
3. Verify request status is 'approved'
4. Check for errors in event creation process

---

## 5. Safety & Integrity Checklist

### 5.1 Critical "Don'ts" (AI Guardrails)

#### ❌ NEVER: Hard-Code Role Checks

**FORBIDDEN:**
```javascript
// WRONG: Hard-coded role check
if (user.role === 'coordinator') {
  // Allow action
}

// WRONG: Role-based authority check
if (user.role === 'Admin' || user.role === 'System Admin') {
  // Bypass check
}
```

**REQUIRED:**
```javascript
// CORRECT: Permission-based check
const hasPermission = await permissionService.checkPermission(
  userId,
  'request',
  'review',
  { locationId }
);

// CORRECT: Authority-based check (when needed)
const userAuthority = await authorityService.calculateUserAuthority(userId);
const requesterAuthority = request.requester?.authoritySnapshot || 0;
if (userAuthority >= requesterAuthority) {
  // Allow action
}
```

#### ❌ NEVER: Bypass State Machine

**FORBIDDEN:**
```javascript
// WRONG: Direct status update
request.status = 'approved';
await request.save();

// WRONG: Manual state transition
request.status = REQUEST_STATES.APPROVED;
```

**REQUIRED:**
```javascript
// CORRECT: Use state machine
const canTransition = await V2RequestStateMachine.canTransition(
  currentState,
  action,
  userId,
  request,
  { locationId }
);

if (!canTransition) {
  throw new Error('Transition not allowed');
}

const nextState = V2RequestStateMachine.getNextState(currentState, action);
request.status = nextState;
```

#### ❌ NEVER: Bypass Permission Middleware

**FORBIDDEN:**
```javascript
// WRONG: Route without permission check
router.post('/event-requests', authenticate, async (req, res) => {
  // No permission check
});

// WRONG: Manual permission check in controller
if (!await permissionService.checkPermission(...)) {
  // Handle in controller
}
```

**REQUIRED:**
```javascript
// CORRECT: Use requirePermission middleware
router.post(
  '/event-requests',
  authenticate,
  requirePermission('request', 'initiate'),
  validateCreateEventRequest,
  async (req, res, next) => {
    // Controller logic
  }
);
```

#### ❌ NEVER: Remove Location Hierarchy Checks

**FORBIDDEN:**
```javascript
// WRONG: No location scoping
const hasPermission = await permissionService.checkPermission(
  userId,
  'request',
  'review',
  {} // Missing locationId
);

// WRONG: Ignore location hierarchy
const reviewers = await User.find({
  authority: { $gte: 60 }
}); // No location filtering
```

**REQUIRED:**
```javascript
// CORRECT: Include location context
const locationId = request.municipalityId || request.district;
const hasPermission = await permissionService.checkPermission(
  userId,
  'request',
  'review',
  { locationId }
);

// CORRECT: Use reviewer resolver (includes location matching)
const reviewers = await v2ReviewerResolver.findReviewersForLocation(
  locationId,
  organizationType,
  { requesterId, requesterAuthority }
);
```

#### ❌ NEVER: Modify v1.0 Files

**FORBIDDEN:**
- Editing files in `src/services/eventRequests_services/` (v1.0)
- Editing files in `src/controller/eventRequests_controller/` (v1.0)
- Editing `src/routes/eventRequests.routes.js` (v1.0)
- Removing or renaming v1.0 files

**REQUIRED:**
- All v2.0 changes in `v2.0_*` subfolders
- v1.0 files remain untouched
- Both versions run in parallel

### 5.2 Mandatory Rules for AI Agents

#### Rule 1: Permission-First Architecture

**Before ANY access check:**
1. Identify required permission: `resource.action` (e.g., `request.review`)
2. Get location context: `locationId` from request or user
3. Call `permissionService.checkPermission(userId, resource, action, { locationId })`
4. Check authority hierarchy if needed: `reviewerAuthority >= requesterAuthority`

**Files to reference:**
- `src/services/users_services/permission.service.js`
- `src/services/users_services/authority.service.js`

#### Rule 2: State Machine Sovereignty

**Before ANY state change:**
1. Get current state: `V2RequestStateMachine.normalizeState(request.status)`
2. Validate transition: `V2RequestStateMachine.isValidTransition(currentState, action)`
3. Check permissions: `V2RequestStateMachine.canTransition(...)`
4. Get next state: `V2RequestStateMachine.getNextState(currentState, action)`
5. Update request: `request.status = nextState`

**Files to reference:**
- `src/services/v2.0_eventServices/v2.0_requestStateMachine.js`

#### Rule 3: Jurisdiction-Based Visibility

**Before ANY reviewer discovery:**
1. Get request location: `municipalityId || district`
2. Get organization type: `request.organizationType`
3. Use `v2ReviewerResolver.findReviewersForLocation(locationId, organizationType)`
4. Verify coverage area match
5. Verify organization type match
6. Verify permission: `request.review`

**Files to reference:**
- `src/services/v2.0_eventServices/v2.0_reviewerResolver.service.js`

#### Rule 4: Standardized Response Format

**ALL controller responses MUST use:**
```javascript
{
  success: true|false,
  message: "Human-readable message",
  data: { ... },
  code?: "ERROR_CODE" // Only for errors
}
```

**Files to reference:**
- `src/controller/v2.0_eventControllers/eventRequest.controller.js`

#### Rule 5: Reschedule Loop Logic

**When handling reschedule:**
1. Identify proposer: Check if `userId === request.requester.userId`
2. If requester rescheduled → activeResponder = any reviewer
3. If reviewer rescheduled → activeResponder = requester
4. Use `V2RequestStateMachine.determineActiveResponder(request, lastActorId)`

**Files to reference:**
- `src/services/v2.0_eventServices/v2.0_requestStateMachine.js` (determineActiveResponder)

---

## 6. Reschedule Loop Logic (Detailed)

### 6.1 Proposer vs Responder Identification

**Key Principle:** Identity-based, NOT role-based

**Proposer Identification:**
```javascript
// Check if user is original requester
const isRequester = V2RequestStateMachine.isRequester(userId, request);

// Check if user has review permission (proxy for reviewer)
const isReviewer = await V2RequestStateMachine.isReviewer(userId, request, locationId);
```

**Responder Determination:**
- If **requester** reschedules → Next responder is **any reviewer** with jurisdiction
- If **reviewer** reschedules → Next responder is **requester**

### 6.2 Active Responder Structure

**For Specific User:**
```javascript
request.activeResponder = {
  userId: ObjectId,        // Specific user who should respond
  relationship: 'requester' | 'reviewer',
  authority: Number        // User's authority level
};
```

**For Broadcast (Any Reviewer):**
```javascript
request.activeResponder = {
  relationship: 'reviewer'
  // No userId - indicates ANY reviewer with jurisdiction can act
};
```

### 6.3 Loop Termination

**Loop continues until:**
1. **Accept**: Reviewer accepts → `approved`
2. **Reject**: Reviewer rejects → `rejected`
3. **Confirm**: Requester confirms → `approved`
4. **Decline**: Requester declines → `rejected`

**Loop does NOT terminate on:**
- Reschedule (creates new loop iteration)

### 6.4 Implementation Details

**File:** `src/services/v2.0_eventServices/v2.0_requestStateMachine.js`

**Method:** `determineActiveResponder(request, lastActorId)`

**Logic Flow:**
```
1. Get current state
2. If final state → return null
3. If pending-review → return { relationship: 'reviewer' } (broadcast)
4. If review-rescheduled:
   a. Check if lastActorId === requester.userId
   b. If requester → return { relationship: 'reviewer' } (broadcast)
   c. If reviewer → return { userId: requester.userId, relationship: 'requester' }
```

---

## 7. API Endpoints Reference

### 7.1 v2.0 Endpoints

| **Method** | **Endpoint** | **Permission** | **Description** |
|------------|--------------|----------------|-----------------|
| POST | `/api/v2/event-requests` | `request.initiate` | Create new request |
| GET | `/api/v2/event-requests` | `request.read` | List requests (jurisdiction-filtered) |
| GET | `/api/v2/event-requests/:id` | `request.read` | Get request details |
| PUT | `/api/v2/event-requests/:id` | (requester only) | Update request (pending only) |
| POST | `/api/v2/event-requests/:id/actions` | (permission-based) | Execute action |
| GET | `/api/v2/event-requests/:id/reviewers` | `request.read` | Get available reviewers |

### 7.2 Action Types

| **Action** | **Required Permission** | **Allowed States** | **Next State** |
|------------|------------------------|-------------------|----------------|
| `accept` | `request.review` | `pending-review`, `review-rescheduled` | `approved` |
| `reject` | `request.review` | `pending-review`, `review-rescheduled` | `rejected` |
| `reschedule` | `request.reschedule` | `pending-review`, `review-rescheduled`, `approved` | `review-rescheduled` |
| `confirm` | `request.confirm` (requester only) | `review-rescheduled` | `approved` |
| `decline` | `request.confirm` (requester only) | `review-rescheduled` | `rejected` |
| `cancel` | `request.cancel` | `pending-review`, `approved` | `cancelled` |

---

## 8. File Purpose Reference

### 8.1 Core Service Files

**`v2.0_requestStateMachine.js`**
- **Purpose:** State transition rules and validation
- **Key Methods:**
  - `isValidTransition()` - Check if transition is valid
  - `getNextState()` - Get next state for transition
  - `canTransition()` - Permission-based transition check
  - `determineActiveResponder()` - Reschedule loop logic
  - `isRequester()` - Check if user is requester
  - `isReviewer()` - Check if user can review
- **DO NOT:** Modify transition rules without updating all dependent logic

**`v2.0_eventRequest.service.js`**
- **Purpose:** Request lifecycle management
- **Key Methods:**
  - `createRequest()` - Create new request
  - `executeAction()` - Execute action on request
  - `getRequestById()` - Get request with permission check
  - `getRequests()` - List requests (jurisdiction-filtered)
  - `updateRequest()` - Update request (pending only)
- **DO NOT:** Directly update request status (use state machine)

**`v2.0_reviewerResolver.service.js`**
- **Purpose:** Jurisdiction-based reviewer discovery
- **Key Methods:**
  - `findReviewersForLocation()` - Find reviewers for location
  - `checkJurisdictionMatch()` - Verify jurisdiction match
  - `findReviewersForRequest()` - Find reviewers for request
- **DO NOT:** Bypass location or organization type matching

**`v2.0_event.service.js`**
- **Purpose:** Event creation from approved requests
- **Key Methods:**
  - `createEventFromRequest()` - Create event from request
  - `updateEventFromRequest()` - Update event from request
  - `shouldPublishEvent()` - Check if event should be created
- **DO NOT:** Create events for non-approved requests

### 8.2 Controller Files

**`v2.0_eventRequest.controller.js`**
- **Purpose:** HTTP request/response handling
- **Key Methods:**
  - `createEventRequest()` - Handle POST /event-requests
  - `getEventRequests()` - Handle GET /event-requests
  - `getEventRequestById()` - Handle GET /event-requests/:id
  - `updateEventRequest()` - Handle PUT /event-requests/:id
  - `executeAction()` - Handle POST /event-requests/:id/actions
  - `getReviewers()` - Handle GET /event-requests/:id/reviewers
- **DO NOT:** Include business logic (delegate to services)
- **MUST:** Use standardized response format

### 8.3 Validator Files

**`v2.0_eventValidators/eventRequest.validators.js`**
- **Purpose:** Input validation using Joi
- **Key Validators:**
  - `validateCreateEventRequest` - Create request validation
  - `validateUpdateEventRequest` - Update request validation
  - `validateRequestId` - Request ID parameter validation
  - `validateExecuteAction` - Action execution validation
- **DO NOT:** Bypass validation in routes

---

## 9. Integration Points

### 9.1 Shared Services

**Permission Service:**
- **File:** `src/services/users_services/permission.service.js`
- **Usage:** `permissionService.checkPermission(userId, resource, action, context)`
- **Context:** `{ locationId }` for location-scoped permissions

**Authority Service:**
- **File:** `src/services/users_services/authority.service.js`
- **Usage:** `authorityService.calculateUserAuthority(userId)`
- **Returns:** Authority tier (20-100)

**Notification Engine:**
- **File:** `src/services/utility_services/notificationEngine.service.js`
- **Usage:** `notificationEngine.notifyRequestCreated(request)`
- **Triggers:** Socket.IO events, email notifications

### 9.2 Shared Models

**EventRequest Model:**
- **File:** `src/models/eventRequests_models/eventRequest.model.js`
- **Key Fields:**
  - `Request_ID` - Unique identifier
  - `status` - Current state
  - `requester` - Requester snapshot
  - `reviewer` - Reviewer snapshot (optional in broadcast model)
  - `validCoordinators` - All valid reviewers (broadcast model)
  - `activeResponder` - Who should respond next
  - `rescheduleProposal` - Reschedule details

**Event Model:**
- **File:** `src/models/events_models/event.model.js`
- **Created From:** Approved requests via `v2.0_event.service.js`

---

## 10. Testing & Validation Checklist

### 10.1 Pre-Deployment Checklist

- [ ] All permission checks use `permissionService.checkPermission()`
- [ ] No hard-coded role checks (`role === 'coordinator'`)
- [ ] All state transitions go through state machine
- [ ] Location scoping preserved in all permission checks
- [ ] Reschedule loop logic tested (requester ↔ reviewer)
- [ ] Broadcast visibility tested (multiple reviewers can see)
- [ ] Response format standardized (`{ success, message, data }`)
- [ ] v1.0 files untouched
- [ ] Routes registered in `routes/index.js`
- [ ] Validators applied to all routes

### 10.2 Common Test Scenarios

**Test 1: Permission-Based Access**
- User without `request.review` cannot review
- User with `request.review` can review (if jurisdiction matches)
- Authority hierarchy enforced (reviewer >= requester)

**Test 2: State Transitions**
- Invalid transitions rejected
- Valid transitions succeed
- State history updated correctly

**Test 3: Reschedule Loop**
- Requester reschedules → Reviewer becomes active responder
- Reviewer reschedules → Requester becomes active responder
- Loop continues until accept/reject/confirm/decline

**Test 4: Broadcast Visibility**
- Multiple reviewers with matching jurisdiction can see request
- Reviewers without matching jurisdiction cannot see
- Organization type matching enforced

---

## 11. Migration Guide (v1.0 → v2.0)

### 11.1 Frontend Migration

**Step 1: Update API Endpoints**
```javascript
// Old (v1.0)
const response = await fetch('/api/event-requests');

// New (v2.0)
const response = await fetch('/api/v2/event-requests');
```

**Step 2: Update Response Handling**
```javascript
// v2.0 uses standardized format
const { success, message, data } = await response.json();
if (success) {
  const requests = data.requests;
}
```

**Step 3: Update Action Execution**
```javascript
// v2.0 action format
await fetch(`/api/v2/event-requests/${requestId}/actions`, {
  method: 'POST',
  body: JSON.stringify({
    action: 'accept', // or 'reject', 'reschedule', 'confirm', 'decline', 'cancel'
    notes: 'Optional notes'
  })
});
```

### 11.2 Backend Migration

**No backend migration required** - v2.0 runs in parallel with v1.0.

**Gradual Migration Strategy:**
1. Deploy v2.0 alongside v1.0
2. Update frontend to use v2.0 endpoints for new features
3. Migrate existing features one by one
4. Keep v1.0 for backward compatibility
5. Eventually deprecate v1.0 (future decision)

---

## 12. Troubleshooting Quick Reference

### 12.1 Error: "Transition not allowed"

**Check:**
1. Current state: `request.status`
2. Action: Valid action type?
3. Permissions: `permissionService.checkPermission()`
4. Authority: `reviewerAuthority >= requesterAuthority`

**Fix:**
- Verify state machine transition rules
- Check user permissions
- Verify authority hierarchy

### 12.2 Error: "User does not have permission"

**Check:**
1. Permission: `request.review` (or appropriate permission)
2. Location: `locationId` in permission context
3. Authority: User's authority level
4. Jurisdiction: Coverage area + organization type match

**Fix:**
- Verify user has required permission
- Check location scoping
- Verify jurisdiction matching

### 12.3 Error: "Request not found"

**Check:**
1. Request ID: Valid `Request_ID`?
2. Access: User has permission to view?
3. Jurisdiction: Request in user's jurisdiction?

**Fix:**
- Verify request exists
- Check permission checks
- Verify jurisdiction filtering

---

## 13. Version Control & Maintenance

### 13.1 File Modification Rules

**v2.0 Files (Modifiable):**
- All files in `v2.0_*` subfolders
- `src/routes/v2.0_eventRoutes.js`
- This documentation file

**v1.0 Files (Read-Only for v2.0):**
- `src/services/eventRequests_services/*` (except shared services)
- `src/controller/eventRequests_controller/*`
- `src/routes/eventRequests.routes.js`

**Shared Files (Modifiable with Caution):**
- Models (only if schema changes needed)
- Core services (permission, authority, notification)
- Middleware (if new functionality needed)

### 13.2 Documentation Updates

**When to Update This Document:**
- New v2.0 endpoints added
- State machine transitions changed
- Permission requirements changed
- Reschedule loop logic modified
- New debugging scenarios identified

**Documentation Standards:**
- Keep high-density, machine-readable format
- Update debugging matrix for new issues
- Maintain safety checklist accuracy
- Keep file purpose reference current

---

## 14. Conclusion

**v2.0 Architecture Summary:**
- **Permission-First**: All access via `permissionService.checkPermission()`
- **State Machine Sovereignty**: All transitions via `V2RequestStateMachine`
- **Broadcast Visibility**: Jurisdiction-based reviewer discovery
- **Reschedule Loop**: Identity-based proposer/responder logic
- **Backward Compatible**: Runs parallel to v1.0

**For AI Agents:**
- Always check this document before modifying v2.0 code
- Follow the safety checklist
- Use the debugging matrix
- Respect state machine sovereignty
- Never hard-code role checks

**For Human Developers:**
- This document is the source of truth for v2.0
- Update when making architectural changes
- Keep debugging matrix current
- Maintain safety checklist accuracy

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-XX  
**Maintained By:** Backend Architecture Team  
**Review Cycle:** Quarterly
