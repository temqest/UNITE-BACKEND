# UNITE Request Flow v2.0 Implementation & Migration Plan

**Version:** 2.0  
**Document Type:** Development Plan  
**Target Audience:** Development Team, AI Agents  
**Status:** Ready for Implementation

---

## 1. Problem Understanding

### 1.1 Current System Bottlenecks (v1.0)

**Role-Based Hard-Coding Issues:**
- Hard-coded role checks (`role === 'coordinator'`, `role === 'stakeholder'`) scattered throughout codebase
- Fragmented logic between `eventRequest.service.js` and `request.service.js`
- Mixed permission-based and role-based authorization causing inconsistencies
- Difficult to extend with new roles without code changes
- Reviewer assignment logic tied to specific role names

**State Machine Complexity:**
- Multiple intermediate states (`review-accepted`, `review-rejected`, `awaiting-confirmation`) create confusion
- State transitions not consistently validated
- Reschedule loop logic relies on role names rather than identity

**Frontend-Backend Coupling:**
- Frontend services (`requestsService.ts`) call v1.0 endpoints (`/api/event-requests`)
- UI components assume specific role names for visibility/action gates
- Permission checks duplicated between frontend and backend
- No standardized response format causing inconsistent error handling

**Visibility & Broadcast Issues:**
- Single reviewer assignment model limits flexibility
- No jurisdiction-based broadcast visibility
- Coordinators cannot see requests in their coverage area unless explicitly assigned

### 1.2 Impact Assessment

**Maintenance Burden:**
- Adding new roles requires code changes in multiple files
- Debugging permission issues requires tracing through role checks
- State transition bugs difficult to isolate

**Scalability Limitations:**
- Cannot easily add new reviewer types
- Location-based visibility not properly implemented
- Reschedule loop breaks with non-standard role configurations

**User Experience:**
- Inconsistent permission enforcement
- Some users cannot see requests they should be able to review
- Confusing state transitions for end users

---

## 2. Key Requirements

### 2.1 Functional Requirements

**Backend v2.0:**
1. **Permission-First Architecture**: All access checks use `permissionService.checkPermission()`
2. **Broadcast Visibility**: Requests visible to ANY reviewer with matching jurisdiction (Coverage Area + Organization Type)
3. **Simplified State Machine**: Reduced states (pending-review → approved/rejected/rescheduled)
4. **Reschedule Loop**: Identity-based "Proposer ↔ Responder" logic (Requester vs Reviewer, not role names)
5. **Double-Confirmation**: Reviewer decision + Requester confirmation required
6. **Standardized Responses**: All endpoints return `{ success, message, data }`

**Frontend Migration:**
1. **Service Layer Update**: Create v2.0 service hooks using `/api/v2/` endpoints
2. **Permission-Based UI Gates**: Replace role checks with `permissionUtils.hasCapability()`
3. **Gradual Migration**: Support both v1.0 and v2.0 during transition period
4. **Response Format Handling**: Update all API call handlers to use standardized format

### 2.2 Non-Functional Requirements

**Performance:**
- v2.0 endpoints must match or exceed v1.0 response times
- Cache invalidation must work correctly with v2.0 responses
- Broadcast reviewer discovery must be optimized (coverage area indexing)

**Reliability:**
- Zero breaking changes to v1.0 during migration
- Backward compatibility maintained for at least 6 months
- Graceful degradation if v2.0 endpoints fail

**Security:**
- All permission checks enforced on backend (frontend checks are advisory only)
- Location scoping preserved in all permission checks
- Authority hierarchy enforced (reviewer >= requester)

**Maintainability:**
- Clear separation between v1.0 and v2.0 code
- Comprehensive documentation for v2.0 architecture
- Easy to debug with clear error messages

---

## 3. Recommended Architecture

### 3.1 Backend Directory Structure (v2.0)

```
src/
├── routes/
│   └── v2.0_eventRoutes.js                    # Routes with /api/v2/ prefix
│
├── controller/
│   └── v2.0_eventControllers/
│       ├── eventRequest.controller.js         # HTTP handlers (standardized responses)
│       └── index.js
│
├── services/
│   └── v2.0_eventServices/
│       ├── v2.0_requestStateMachine.js        # State machine (WORKFLOW SOVEREIGNTY)
│       ├── v2.0_eventRequest.service.js       # Unified request lifecycle
│       ├── v2.0_reviewerResolver.service.js   # Jurisdiction-based reviewer discovery
│       ├── v2.0_event.service.js              # Event creation from approved requests
│       └── index.js
│
└── validators/
    └── v2.0_eventValidators/
        ├── eventRequest.validators.js         # Joi validation schemas
        └── index.js
```

**Shared Dependencies (v1.0 & v2.0):**
- Models: `eventRequest.model.js`, `event.model.js`, `user.model.js`
- Core Services: `permission.service.js`, `authority.service.js`, `notificationEngine.service.js`
- Middleware: `authenticate.js`, `requirePermission.js`, `cacheMiddleware.js`
- Constants: `requestConstants.js`

### 3.2 Frontend Service Structure (v2.0)

```
UNITE/
├── services/
│   └── eventRequestsV2Service.ts              # NEW: v2.0 API service layer
│
├── hooks/
│   ├── useEventRequestsV2.ts                  # NEW: v2.0 request management hook
│   ├── useRequestActionsV2.ts                 # NEW: v2.0 action execution hook
│   └── useRequestReviewersV2.ts                # NEW: v2.0 reviewer discovery hook
│
├── utils/
│   ├── permissionUtils.ts                     # EXISTING: Update to support v2.0
│   ├── fetchWithAuth.ts                       # EXISTING: Reuse for v2.0 calls
│   └── requestCache.ts                        # EXISTING: Update cache keys for v2.0
│
└── components/
    └── campaign/
        └── services/
            └── requestsService.ts              # EXISTING: Keep for v1.0, create v2.0 version
```

### 3.3 API Endpoint Mapping

| **v1.0 Endpoint** | **v2.0 Endpoint** | **Changes** |
|-------------------|-------------------|------------|
| `POST /api/event-requests` | `POST /api/v2/event-requests` | Standardized response format |
| `GET /api/event-requests` | `GET /api/v2/event-requests` | Jurisdiction-based filtering |
| `GET /api/event-requests/:id` | `GET /api/v2/event-requests/:id` | Standardized response format |
| `PUT /api/event-requests/:id` | `PUT /api/v2/event-requests/:id` | Permission-based access |
| `POST /api/event-requests/:id/actions` | `POST /api/v2/event-requests/:id/actions` | Unified action handler |
| N/A | `GET /api/v2/event-requests/:id/reviewers` | NEW: Broadcast visibility |

### 3.4 State Machine Simplification

**v1.0 States (Complex):**
```
pending-review → review-accepted → awaiting-confirmation → approved
              → review-rejected → awaiting-confirmation → rejected
              → review-rescheduled → (loop)
```

**v2.0 States (Simplified):**
```
pending-review → approved (direct)
              → rejected (direct)
              → review-rescheduled → approved/rejected (direct)
                                   → review-rescheduled (loop)
```

**Benefits:**
- Fewer intermediate states reduce confusion
- Direct transitions improve user experience
- Loop logic clearer with identity-based responder determination

---

## 4. Detailed Step-by-Step Plan

### Phase 1: Backend v2.0 Core Services ✅ (COMPLETED)

**Status:** ✅ All core services implemented

**Completed Tasks:**
1. ✅ Created `v2.0_requestStateMachine.js` with permission-based transitions
2. ✅ Created `v2.0_reviewerResolver.service.js` for jurisdiction-based discovery
3. ✅ Created `v2.0_eventRequest.service.js` with unified lifecycle management
4. ✅ Created `v2.0_event.service.js` for event creation from approved requests

**Key Implementation Details:**
- State machine uses `permissionService.checkPermission()` for all gates
- Reviewer resolver matches Coverage Area + Organization Type
- Reschedule loop uses `determineActiveResponder()` based on requester vs reviewer identity
- All services follow permission-first architecture

### Phase 2: Backend v2.0 API & Validation ✅ (COMPLETED)

**Status:** ✅ All API endpoints and validators implemented

**Completed Tasks:**
1. ✅ Created `v2.0_eventValidators/eventRequest.validators.js` with Joi schemas
2. ✅ Created `v2.0_eventRequest.controller.js` with standardized response format
3. ✅ Created `v2.0_eventRoutes.js` with `/api/v2/` prefix
4. ✅ Registered routes in `src/routes/index.js`

**Key Implementation Details:**
- All responses use `{ success, message, data }` format
- Validators enforce action-specific requirements (e.g., `proposedDate` for reschedule)
- Routes use `requirePermission` middleware
- Cache invalidation integrated

### Phase 3: Frontend Service Layer (TODO)

**Objective:** Create v2.0 service layer and hooks for frontend integration

#### 3.1 Create v2.0 Service File

**File:** `UNITE/services/eventRequestsV2Service.ts`

**Implementation:**
```typescript
import { fetchJsonWithAuth } from '@/utils/fetchWithAuth';

const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:6700';

/**
 * v2.0 Event Request Service
 * Uses /api/v2/ endpoints with standardized response format
 */

export interface V2RequestResponse<T = any> {
  success: boolean;
  message: string;
  data: T;
  code?: string;
}

export interface V2Request {
  Request_ID: string;
  Event_ID?: string;
  status: string;
  requester: {
    userId: string;
    name: string;
    roleSnapshot?: string;
    authoritySnapshot: number;
  };
  reviewer?: {
    userId: string;
    name: string;
    roleSnapshot?: string;
  };
  validCoordinators?: Array<{
    userId: string;
    name: string;
    roleSnapshot?: string;
    authority: number;
  }>;
  activeResponder?: {
    userId?: string;
    relationship: 'requester' | 'reviewer';
    authority?: number;
  };
  Event_Title: string;
  Location: string;
  Start_Date: string;
  End_Date?: string;
  // ... other fields
}

/**
 * Create new event request
 */
export async function createEventRequestV2(
  requestData: Partial<V2Request>
): Promise<V2RequestResponse<{ request: V2Request }>> {
  return fetchJsonWithAuth(`${API_BASE}/api/v2/event-requests`, {
    method: 'POST',
    body: JSON.stringify(requestData),
  });
}

/**
 * Get event requests (jurisdiction-filtered)
 */
export async function getEventRequestsV2(
  filters?: {
    status?: string;
    organizationId?: string;
    coverageAreaId?: string;
    municipalityId?: string;
    district?: string;
    province?: string;
    category?: string;
    page?: number;
    limit?: number;
  }
): Promise<V2RequestResponse<{
  requests: V2Request[];
  pagination: {
    page: number;
    limit: number;
    totalCount: number;
    totalPages: number;
  };
}>> {
  const queryParams = new URLSearchParams();
  if (filters) {
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams.append(key, String(value));
      }
    });
  }
  
  const url = `${API_BASE}/api/v2/event-requests${queryParams.toString() ? `?${queryParams}` : ''}`;
  return fetchJsonWithAuth(url);
}

/**
 * Get event request by ID
 */
export async function getEventRequestByIdV2(
  requestId: string
): Promise<V2RequestResponse<{ request: V2Request }>> {
  return fetchJsonWithAuth(`${API_BASE}/api/v2/event-requests/${encodeURIComponent(requestId)}`);
}

/**
 * Update event request (pending state only)
 */
export async function updateEventRequestV2(
  requestId: string,
  updateData: Partial<V2Request>
): Promise<V2RequestResponse<{ request: V2Request }>> {
  return fetchJsonWithAuth(`${API_BASE}/api/v2/event-requests/${encodeURIComponent(requestId)}`, {
    method: 'PUT',
    body: JSON.stringify(updateData),
  });
}

/**
 * Execute action on request
 */
export async function executeRequestActionV2(
  requestId: string,
  action: 'accept' | 'reject' | 'reschedule' | 'confirm' | 'decline' | 'cancel',
  actionData?: {
    notes?: string;
    proposedDate?: string;
    proposedStartTime?: string;
    proposedEndTime?: string;
  }
): Promise<V2RequestResponse<{
  request: V2Request;
  event?: {
    Event_ID: string;
    Event_Title: string;
    Status: string;
  };
}>> {
  return fetchJsonWithAuth(`${API_BASE}/api/v2/event-requests/${encodeURIComponent(requestId)}/actions`, {
    method: 'POST',
    body: JSON.stringify({
      action,
      ...actionData,
    }),
  });
}

/**
 * Get available reviewers for request (broadcast visibility)
 */
export async function getRequestReviewersV2(
  requestId: string
): Promise<V2RequestResponse<{
  reviewers: Array<{
    userId: string;
    name: string;
    roleSnapshot?: string;
    authority: number;
    organizationType?: string;
  }>;
  count: number;
}>> {
  return fetchJsonWithAuth(`${API_BASE}/api/v2/event-requests/${encodeURIComponent(requestId)}/reviewers`);
}
```

#### 3.2 Create v2.0 Hooks

**File:** `UNITE/hooks/useEventRequestsV2.ts`

**Implementation:**
```typescript
import { useState, useEffect, useCallback } from 'react';
import {
  getEventRequestsV2,
  getEventRequestByIdV2,
  createEventRequestV2,
  updateEventRequestV2,
  V2Request,
  V2RequestResponse,
} from '@/services/eventRequestsV2Service';
import { invalidateCache } from '@/utils/requestCache';

interface UseEventRequestsV2Options {
  filters?: {
    status?: string;
    organizationId?: string;
    coverageAreaId?: string;
    municipalityId?: string;
    district?: string;
    province?: string;
    category?: string;
  };
  autoFetch?: boolean;
  page?: number;
  limit?: number;
}

export function useEventRequestsV2(options: UseEventRequestsV2Options = {}) {
  const { filters, autoFetch = true, page = 1, limit = 20 } = options;
  
  const [requests, setRequests] = useState<V2Request[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20,
    totalCount: 0,
    totalPages: 0,
  });

  const fetchRequests = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await getEventRequestsV2({
        ...filters,
        page,
        limit,
      });
      
      if (response.success) {
        setRequests(response.data.requests);
        setPagination(response.data.pagination);
      } else {
        setError(response.message || 'Failed to fetch requests');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to fetch requests');
    } finally {
      setLoading(false);
    }
  }, [filters, page, limit]);

  useEffect(() => {
    if (autoFetch) {
      fetchRequests();
    }
  }, [autoFetch, fetchRequests]);

  // Listen for request change events
  useEffect(() => {
    const handleRequestChange = () => {
      if (autoFetch) {
        invalidateCache(/event-requests/);
        fetchRequests();
      }
    };

    window.addEventListener('unite:requests-changed', handleRequestChange);
    return () => {
      window.removeEventListener('unite:requests-changed', handleRequestChange);
    };
  }, [autoFetch, fetchRequests]);

  return {
    requests,
    loading,
    error,
    pagination,
    refetch: fetchRequests,
  };
}
```

**File:** `UNITE/hooks/useRequestActionsV2.ts`

**Implementation:**
```typescript
import { useState, useCallback } from 'react';
import { executeRequestActionV2 } from '@/services/eventRequestsV2Service';
import { invalidateCache } from '@/utils/requestCache';

export function useRequestActionsV2() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const executeAction = useCallback(async (
    requestId: string,
    action: 'accept' | 'reject' | 'reschedule' | 'confirm' | 'decline' | 'cancel',
    actionData?: {
      notes?: string;
      proposedDate?: string;
      proposedStartTime?: string;
      proposedEndTime?: string;
    }
  ) => {
    setLoading(true);
    setError(null);

    try {
      const response = await executeRequestActionV2(requestId, action, actionData);
      
      if (response.success) {
        // Invalidate cache
        invalidateCache(/event-requests/);
        
        // Dispatch event for other components
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('unite:requests-changed', {
            detail: {
              requestId,
              action,
              timestamp: Date.now(),
              shouldRefresh: true,
            },
          }));
        }
        
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to execute action');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to execute action');
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    executeAction,
    loading,
    error,
  };
}
```

**File:** `UNITE/hooks/useRequestReviewersV2.ts`

**Implementation:**
```typescript
import { useState, useEffect, useCallback } from 'react';
import { getRequestReviewersV2 } from '@/services/eventRequestsV2Service';

export function useRequestReviewersV2(requestId: string | null) {
  const [reviewers, setReviewers] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchReviewers = useCallback(async () => {
    if (!requestId) {
      setReviewers([]);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await getRequestReviewersV2(requestId);
      
      if (response.success) {
        setReviewers(response.data.reviewers);
      } else {
        setError(response.message || 'Failed to fetch reviewers');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to fetch reviewers');
    } finally {
      setLoading(false);
    }
  }, [requestId]);

  useEffect(() => {
    fetchReviewers();
  }, [fetchReviewers]);

  return {
    reviewers,
    loading,
    error,
    refetch: fetchReviewers,
  };
}
```

#### 3.3 Update Permission Utilities

**File:** `UNITE/utils/permissionUtils.ts` (Update existing)

**Add v2.0-specific helpers:**
```typescript
/**
 * Check if user can perform action on request (v2.0 permission-based)
 * @param user - User object with permissions
 * @param action - Action to check ('accept', 'reject', 'reschedule', 'confirm', 'decline', 'cancel')
 * @param request - Request object
 * @returns True if user can perform action
 */
export function canPerformRequestActionV2(
  user: UserWithPermissions,
  action: 'accept' | 'reject' | 'reschedule' | 'confirm' | 'decline' | 'cancel',
  request: any
): boolean {
  // Check if user is requester (for confirm/decline)
  const isRequester = user._id === request.requester?.userId;
  
  if (action === 'confirm' || action === 'decline') {
    return isRequester && hasCapability(user, 'request.confirm');
  }
  
  // For review actions, check review permission
  if (action === 'accept' || action === 'reject') {
    return hasCapability(user, 'request.review');
  }
  
  // For reschedule, check reschedule permission
  if (action === 'reschedule') {
    return hasCapability(user, 'request.reschedule');
  }
  
  // For cancel, check cancel permission
  if (action === 'cancel') {
    return (isRequester || hasCapability(user, 'request.review')) && 
           hasCapability(user, 'request.cancel');
  }
  
  return false;
}

/**
 * Check if user can see request (v2.0 broadcast visibility)
 * @param user - User object
 * @param request - Request object
 * @returns True if user can see request
 */
export function canViewRequestV2(
  user: UserWithPermissions,
  request: any
): boolean {
  // System admins can see all
  if (user.authority >= 100) {
    return true;
  }
  
  // Requester can always see their request
  if (user._id === request.requester?.userId) {
    return true;
  }
  
  // Check if user is in validCoordinators (broadcast model)
  const isInValidCoordinators = request.validCoordinators?.some(
    (coord: any) => coord.userId === user._id
  );
  
  if (isInValidCoordinators) {
    return true;
  }
  
  // Check if user has request.read permission
  return hasCapability(user, 'request.read');
}
```

### Phase 4: Frontend UI Migration (TODO)

**Objective:** Gradually migrate UI components to use v2.0 services

#### 4.1 Create Feature Flag

**File:** `UNITE/utils/featureFlags.ts`

```typescript
/**
 * Feature flags for gradual v2.0 migration
 */
export const FEATURE_FLAGS = {
  USE_V2_REQUEST_FLOW: process.env.NEXT_PUBLIC_USE_V2_REQUESTS === 'true' || false,
} as const;

export function useV2RequestFlow(): boolean {
  return FEATURE_FLAGS.USE_V2_REQUEST_FLOW;
}
```

#### 4.2 Update Request List Component

**File:** Update component that displays request list

**Changes:**
1. Import `useEventRequestsV2` hook
2. Add feature flag check: `useV2RequestFlow()`
3. Conditionally use v2.0 or v1.0 hook based on flag
4. Update response format handling

**Example:**
```typescript
import { useEventRequestsV2 } from '@/hooks/useEventRequestsV2';
import { useV2RequestFlow } from '@/utils/featureFlags';
// ... existing v1.0 imports

function RequestListComponent() {
  const useV2 = useV2RequestFlow();
  
  // v2.0 hook
  const v2Data = useEventRequestsV2({
    filters: { status: 'pending-review' },
    autoFetch: useV2,
  });
  
  // v1.0 hook (existing)
  const v1Data = useEventRequests(/* ... */);
  
  const requests = useV2 ? v2Data.requests : v1Data.requests;
  const loading = useV2 ? v2Data.loading : v1Data.loading;
  
  // ... rest of component
}
```

#### 4.3 Update Action Buttons

**File:** Update components with action buttons (accept/reject/reschedule/etc.)

**Changes:**
1. Import `useRequestActionsV2` hook
2. Replace `performRequestAction` calls with `executeAction` from v2.0 hook
3. Update permission checks to use `canPerformRequestActionV2`
4. Handle standardized response format

**Example:**
```typescript
import { useRequestActionsV2 } from '@/hooks/useRequestActionsV2';
import { canPerformRequestActionV2 } from '@/utils/permissionUtils';
import { useV2RequestFlow } from '@/utils/featureFlags';

function RequestActionButtons({ request, user }) {
  const useV2 = useV2RequestFlow();
  const { executeAction, loading } = useRequestActionsV2();
  
  const canAccept = useV2 
    ? canPerformRequestActionV2(user, 'accept', request)
    : hasCapability(user, 'request.review'); // v1.0 check
  
  const handleAccept = async () => {
    if (useV2) {
      await executeAction(request.Request_ID, 'accept');
    } else {
      await performRequestAction(request.Request_ID, 'accept');
    }
  };
  
  // ... rest of component
}
```

#### 4.4 Update Request Detail View

**File:** Update request detail/modal component

**Changes:**
1. Use `getEventRequestByIdV2` for fetching details
2. Display `validCoordinators` list (broadcast visibility)
3. Show `activeResponder` information
4. Update reschedule UI to handle v2.0 loop logic

#### 4.5 Update Request Creation Form

**File:** Update request creation modal/form

**Changes:**
1. Use `createEventRequestV2` service
2. Remove coordinator selection (handled by broadcast model)
3. Update validation to match v2.0 validators
4. Handle standardized response format

#### 4.6 Migration Checklist

**Components to Update:**
- [ ] Request list view (`/dashboard/campaign` or similar)
- [ ] Request detail modal
- [ ] Request action buttons (accept/reject/reschedule/confirm/cancel)
- [ ] Request creation form
- [ ] Request update form
- [ ] Reschedule modal
- [ ] Reviewer visibility display

**Gradual Migration Strategy:**
1. Deploy v2.0 backend (already done)
2. Deploy v2.0 frontend services and hooks
3. Enable feature flag for internal testing
4. Test with small user group
5. Gradually enable for all users
6. Monitor error rates and performance
7. Once stable, make v2.0 default
8. Eventually deprecate v1.0 (future decision)

---

## 5. Tools / Technologies to Use

### 5.1 Backend Stack

**Already Implemented:**
- Node.js / Express
- Mongoose (MongoDB)
- Joi (Validation)
- Existing permission/authority services

**No New Dependencies Required**

### 5.2 Frontend Stack

**Existing:**
- Next.js 14
- TypeScript
- HeroUI (UI components)
- React Hooks

**New Dependencies:**
- None (reuse existing utilities)

**Utilities to Reuse:**
- `fetchWithAuth` / `fetchJsonWithAuth` - Authentication
- `permissionUtils` - Permission checking (update for v2.0)
- `requestCache` - Cache invalidation
- `authorityUtils` - Authority calculations

### 5.3 Development Tools

**Testing:**
- Postman / Insomnia for API testing
- React Testing Library for component tests
- Jest for unit tests

**Monitoring:**
- Error tracking (existing system)
- Performance monitoring
- Feature flag analytics

---

## 6. Risks + Mitigation

### 6.1 Data Consistency Between v1.0 and v2.0

**Risk:** Users using v1.0 and v2.0 simultaneously could see inconsistent data

**Mitigation:**
- Both versions use same database models (no schema changes)
- Cache invalidation events work for both versions
- Feature flag ensures users only use one version at a time
- Monitor for data inconsistencies during migration

### 6.2 Permission Check Discrepancies

**Risk:** Frontend permission checks might not match backend v2.0 logic

**Mitigation:**
- Backend always enforces permissions (frontend checks are advisory)
- Update `permissionUtils.ts` to match v2.0 logic
- Add integration tests for permission scenarios
- Log permission mismatches for debugging

### 6.3 Reschedule Loop Logic Complexity

**Risk:** Identity-based responder determination might confuse users

**Mitigation:**
- Clear UI indicators showing who should respond next
- Display `activeResponder` information prominently
- Add tooltips explaining reschedule loop
- Comprehensive testing of loop scenarios

### 6.4 Broadcast Visibility Performance

**Risk:** Finding all reviewers for a request could be slow

**Mitigation:**
- Optimize reviewer resolver with proper indexing
- Cache reviewer lists per request
- Use pagination for large reviewer lists
- Monitor query performance

### 6.5 Frontend Migration Breaking Changes

**Risk:** Updating components might break existing functionality

**Mitigation:**
- Feature flag allows gradual rollout
- Keep v1.0 code intact during migration
- Comprehensive testing before enabling v2.0
- Rollback plan if issues arise

### 6.6 Response Format Changes

**Risk:** Frontend expecting v1.0 format might break with v2.0 standardized format

**Mitigation:**
- Update all API call handlers to use standardized format
- Add response format adapters if needed
- Test all endpoints with v2.0 format
- Document response format changes

---

## 7. Testing Strategy

### 7.1 Backend Testing (v2.0)

**Unit Tests:**
- State machine transition validation
- Permission check logic
- Reviewer resolver jurisdiction matching
- Event creation from approved requests

**Integration Tests:**
- End-to-end request creation flow
- Action execution with permission checks
- Reschedule loop scenarios
- Broadcast visibility queries

**Test Scenarios:**

**Scenario 1: Permission-Based Access**
```
Given: User with request.review permission
When: User tries to accept request
Then: Action succeeds if jurisdiction matches
And: Action fails if jurisdiction doesn't match
```

**Scenario 2: Broadcast Visibility**
```
Given: Request in Municipality A
And: Coordinators with coverage in Municipality A
When: Coordinators fetch requests
Then: They see the request
And: Coordinators without coverage don't see it
```

**Scenario 3: Reschedule Loop**
```
Given: Request in review-rescheduled state
When: Requester reschedules
Then: activeResponder = any reviewer
When: Reviewer reschedules
Then: activeResponder = requester
```

**Scenario 4: State Transitions**
```
Given: Request in pending-review state
When: Reviewer accepts
Then: Status = approved
And: Event is created
```

### 7.2 Frontend Testing

**Component Tests:**
- Request list rendering with v2.0 data
- Action button visibility based on permissions
- Reschedule modal with v2.0 loop logic
- Reviewer list display (broadcast visibility)

**Integration Tests:**
- Full request creation flow
- Action execution flow
- Error handling with standardized format
- Cache invalidation on actions

**E2E Tests:**
- User creates request → Reviewer sees it → Reviewer accepts → Event created
- Reschedule loop: Reviewer reschedules → Requester responds → Loop continues
- Permission gates: User without permission cannot see/act

### 7.3 Performance Testing

**Backend:**
- Reviewer resolver query performance (< 100ms for typical coverage areas)
- State machine transition performance (< 50ms)
- Permission check performance (< 20ms with cache)

**Frontend:**
- Request list load time (< 500ms)
- Action execution time (< 1s including network)
- Cache invalidation performance

### 7.4 Security Testing

**Permission Enforcement:**
- Users without permission cannot access endpoints
- Location scoping properly enforced
- Authority hierarchy respected
- Frontend checks don't bypass backend

**Data Validation:**
- Invalid actions rejected
- Invalid state transitions rejected
- Malformed requests rejected
- SQL injection / XSS prevention (existing)

---

## 8. Deployment & Scalability Strategy

### 8.1 Deployment Phases

**Phase 1: Backend v2.0 Deployment** ✅ (COMPLETED)
- Deploy v2.0 backend services
- Register v2.0 routes
- Monitor for errors
- **Status:** ✅ Complete

**Phase 2: Frontend Service Layer Deployment**
- Deploy v2.0 service files and hooks
- Keep feature flag disabled
- Test internally
- **Timeline:** Week 1-2

**Phase 3: Gradual UI Migration**
- Enable feature flag for internal testing
- Test with small user group (5-10 users)
- Monitor error rates and performance
- **Timeline:** Week 3-4

**Phase 4: Full Rollout**
- Enable feature flag for all users
- Monitor closely for first week
- Collect user feedback
- **Timeline:** Week 5-6

**Phase 5: v2.0 as Default**
- Make v2.0 default (remove feature flag)
- Keep v1.0 available for rollback
- **Timeline:** Week 7-8

**Phase 6: v1.0 Deprecation (Future)**
- Announce v1.0 deprecation
- Set deprecation date (6 months out)
- Migrate remaining users
- Remove v1.0 code
- **Timeline:** 6+ months

### 8.2 Rollback Plan

**If Issues Arise:**
1. Disable feature flag immediately
2. Users automatically fall back to v1.0
3. Investigate issues in v2.0
4. Fix and redeploy
5. Re-enable after verification

**Rollback Triggers:**
- Error rate > 5%
- Performance degradation > 50%
- Critical bugs affecting user workflow
- Data consistency issues

### 8.3 Monitoring & Observability

**Metrics to Monitor:**
- API response times (v2.0 vs v1.0)
- Error rates by endpoint
- Permission check failures
- Cache hit rates
- User adoption (feature flag usage)

**Alerts:**
- Error rate spike (> 5%)
- Response time degradation (> 2s)
- Permission check failures
- Database query timeouts

### 8.4 Scalability Considerations

**Backend:**
- Reviewer resolver queries optimized with indexes
- Permission service uses caching
- State machine is stateless (scales horizontally)
- Database indexes on coverage areas and organization types

**Frontend:**
- Request list pagination (20 items per page)
- Cache invalidation prevents stale data
- Lazy loading for reviewer lists
- Optimistic UI updates for better UX

**Future Optimizations:**
- Redis caching for reviewer lists
- GraphQL for flexible queries
- WebSocket for real-time updates
- CDN for static assets

---

## 9. Success Criteria

### 9.1 Technical Success

- ✅ All v2.0 backend services implemented
- ✅ All v2.0 API endpoints functional
- ✅ Permission-based access working correctly
- ✅ Broadcast visibility working correctly
- ✅ Reschedule loop working correctly
- ⏳ Frontend services and hooks implemented
- ⏳ UI components migrated to v2.0
- ⏳ Feature flag rollout successful
- ⏳ Zero breaking changes to v1.0

### 9.2 Business Success

- Improved user experience (faster, clearer workflows)
- Reduced support tickets related to permissions
- Easier to add new roles/permissions
- Better visibility for coordinators
- Scalable architecture for future growth

### 9.3 Quality Metrics

- Error rate < 1%
- API response time < 500ms (p95)
- Test coverage > 80%
- Zero critical bugs in production
- User satisfaction maintained or improved

---

## 10. Timeline Summary

| **Phase** | **Duration** | **Status** |
|-----------|-------------|------------|
| Phase 1: Backend Core Services | 1 week | ✅ Complete |
| Phase 2: Backend API & Validation | 1 week | ✅ Complete |
| Phase 3: Frontend Service Layer | 2 weeks | ⏳ Pending |
| Phase 4: Frontend UI Migration | 4 weeks | ⏳ Pending |
| **Total Estimated Time** | **8 weeks** | **50% Complete** |

**Current Status:**
- ✅ Backend v2.0: 100% Complete
- ⏳ Frontend Migration: 0% Complete
- **Overall: 50% Complete**

---

## 11. Next Steps

### Immediate Actions (Week 1-2)

1. **Create Frontend Service Layer**
   - Implement `eventRequestsV2Service.ts`
   - Create v2.0 hooks (`useEventRequestsV2`, `useRequestActionsV2`, `useRequestReviewersV2`)
   - Update `permissionUtils.ts` with v2.0 helpers

2. **Testing**
   - Test v2.0 services with Postman
   - Write unit tests for hooks
   - Integration tests for service layer

3. **Documentation**
   - Update frontend API documentation
   - Create migration guide for developers
   - Document feature flag usage

### Short-Term Actions (Week 3-4)

1. **UI Component Updates**
   - Update request list component
   - Update action buttons
   - Update request detail view
   - Update request creation form

2. **Feature Flag Implementation**
   - Add feature flag utility
   - Enable for internal testing
   - Monitor and iterate

### Medium-Term Actions (Week 5-8)

1. **Gradual Rollout**
   - Enable for small user group
   - Collect feedback
   - Fix issues
   - Full rollout

2. **Monitoring & Optimization**
   - Monitor performance metrics
   - Optimize slow queries
   - Improve cache strategy
   - User feedback integration

---

## 12. Conclusion

The v2.0 Permission-Based Request Flow implementation provides a **cleaner, more maintainable, and scalable** architecture for the UNITE system. The backend implementation is **complete and production-ready**. The frontend migration is the next critical phase, requiring careful planning and gradual rollout to ensure zero disruption to existing users.

**Key Benefits:**
- **Permission-First**: No hard-coded role checks
- **Broadcast Visibility**: Better coordinator access
- **Simplified States**: Clearer user experience
- **Identity-Based Logic**: Flexible reschedule loop
- **Standardized Responses**: Consistent error handling

**Risk Mitigation:**
- Feature flags enable gradual rollout
- Backward compatibility maintained
- Comprehensive testing strategy
- Clear rollback plan

**Success Factors:**
- Careful frontend migration
- Thorough testing
- User feedback integration
- Performance monitoring

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-XX  
**Maintained By:** Development Team  
**Next Review:** After Phase 3 Completion
